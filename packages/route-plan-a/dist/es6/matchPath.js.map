{"version":3,"sources":["../../src/matchPath.ts"],"names":["pathToRegexp","cache","cacheLimit","cacheCount","compileToPath","rule","result","compile","compilePath","path","options","end","strict","sensitive","cacheKey","pathCache","keys","regexp","matchPath","pathname","Array","isArray","exact","paths","concat","reduce","matched","url","isExact","params","match","exec","values","memo","key","index","name"],"mappings":"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","sourcesContent":["import pathToRegexp, {Key, PathFunction} from './path-to-regexp.js';\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nexport function compileToPath(rule: string): PathFunction {\n  if (cache[rule]) {\n    return cache[rule];\n  }\n  const result = pathToRegexp.compile(rule);\n  if (cacheCount < cacheLimit) {\n    cache[rule] = result;\n    cacheCount++;\n  }\n  return result;\n}\nexport function compilePath(path: string, options: {end: boolean; strict: boolean; sensitive: boolean} = {end: false, strict: false, sensitive: false}): {regexp: RegExp; keys: Key[]} {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) {\n    return pathCache[path];\n  }\n\n  const keys: any[] = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = {regexp, keys};\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\ninterface MatchResult {\n  params: {[key: string]: string};\n  isExact: boolean;\n  path: string;\n  url: string;\n}\ninterface MatchPathOptions {\n  path?: string | string[];\n  strict?: boolean;\n  exact?: boolean;\n  sensitive?: boolean;\n}\n\nexport function matchPath(pathname: string, options: string | string[] | MatchPathOptions = {}): MatchResult {\n  if (typeof options === 'string' || Array.isArray(options)) {\n    options = {path: options};\n  }\n\n  const {path, exact = false, strict = false, sensitive = false} = options;\n\n  const paths = [].concat(path as any);\n\n  return paths.reduce(\n    (matched, path: string) => {\n      if (!path) return null;\n      if (matched) return matched;\n      if (path === '*') {\n        return {\n          path,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n      }\n      const {regexp, keys} = compilePath(path, {\n        end: exact,\n        strict,\n        sensitive,\n      });\n      const match = regexp.exec(pathname);\n\n      if (!match) return null;\n\n      const [url, ...values] = match;\n      const isExact = pathname === url;\n\n      if (exact && !isExact) return null;\n\n      return {\n        path, // the path used to match\n        url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n        isExact, // whether or not we matched exactly\n        params: keys.reduce((memo: {[key: string]: any}, key: {name: string | number}, index: number) => {\n          memo[key.name] = values[index];\n          return memo;\n        }, {}),\n      };\n    },\n    null as any\n  );\n}\n\nexport default matchPath;\n"],"file":"matchPath.js"}