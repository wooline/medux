{"version":3,"sources":["../../src/path-to-regexp.ts"],"names":["DEFAULT_DELIMITER","balanced","open","close","str","index","count","i","length","parse","options","tokens","defaultDelimiter","delimiter","whitelist","undefined","key","path","isEscaped","prefix","name","pattern","code","charCodeAt","end","slice","TypeError","test","validPattern","replace","char","matches","indexOf","push","repeat","optional","escapeString","compile","tokensToFunction","reFlags","flags","encode","x","validate","map","token","RegExp","data","value","Array","isArray","j","segment","String","typeOfMessage","match","keys","re","pathToRegexp","regexpToFunction","decode","pathname","m","exec","params","Object","create","split","sensitive","regexpToRegexp","groups","source","arrayToRegexp","paths","parts","join","stringToRegexp","tokensToRegexp","strict","start","endsWith","concat","route","capture","endToken","isEndDelimited"],"mappings":"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","sourcesContent":["// fork from path-to-regexp 5.0.0\n// https://github.com/pillarjs/path-to-regexp\n/**\n * Default configs.\n */\nconst DEFAULT_DELIMITER = '/';\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to consider delimiters when parsing. (default: `undefined`, any character)\n   */\n  whitelist?: string | string[];\n}\n\n/**\n * Balanced bracket helper function.\n */\nfunction balanced(open: string, close: string, str: string, index: number) {\n  let count = 0;\n  let i = index;\n\n  while (i < str.length) {\n    if (str[i] === '\\\\') {\n      i += 2;\n      continue;\n    }\n\n    if (str[i] === close) {\n      count--;\n\n      if (count === 0) return i + 1;\n    }\n\n    if (str[i] === open) {\n      count++;\n    }\n\n    i++;\n  }\n\n  return -1;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = [];\n  const defaultDelimiter = options.delimiter ?? DEFAULT_DELIMITER;\n  const whitelist = options.whitelist ?? undefined;\n  let i = 0;\n  let key = 0;\n  let path = '';\n  let isEscaped = false;\n\n  // tslint:disable-next-line\n  while (i < str.length) {\n    let prefix = '';\n    let name = '';\n    let pattern = '';\n\n    // Ignore escaped sequences.\n    if (str[i] === '\\\\') {\n      i++;\n      path += str[i++];\n      isEscaped = true;\n      continue;\n    }\n\n    if (str[i] === ':') {\n      while (++i < str.length) {\n        const code = str.charCodeAt(i);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95 ||\n          // `.`\n          code === 46\n        ) {\n          name += str[i];\n          continue;\n        }\n\n        break;\n      }\n\n      // False positive on param name.\n      if (!name) i--;\n    }\n\n    if (str[i] === '(') {\n      const end = balanced('(', ')', str, i);\n\n      // False positive on matching brackets.\n      if (end > -1) {\n        pattern = str.slice(i + 1, end - 1);\n        i = end;\n\n        if (pattern[0] === '?') {\n          throw new TypeError('Path pattern must be a capturing group');\n        }\n\n        if (/\\((?=[^?])/.test(pattern)) {\n          const validPattern = pattern.replace(/\\((?=[^?])/, '(?:');\n\n          throw new TypeError(`Capturing groups are not allowed in pattern, use a non-capturing group: (${validPattern})`);\n        }\n      }\n    }\n\n    // Add regular characters to the path string.\n    if (name === '' && pattern === '') {\n      path += str[i++];\n      isEscaped = false;\n      continue;\n    }\n\n    // Extract the final character from `path` for the prefix.\n    if (path.length && !isEscaped) {\n      const char = path[path.length - 1];\n      const matches = whitelist ? whitelist.indexOf(char) > -1 : true;\n\n      if (matches) {\n        prefix = char;\n        path = path.slice(0, -1);\n      }\n    }\n\n    // Push the current path onto the list of tokens.\n    if (path.length) {\n      tokens.push(path);\n      path = '';\n    }\n\n    const repeat = str[i] === '+' || str[i] === '*';\n    const optional = str[i] === '?' || str[i] === '*';\n    const delimiter = prefix || defaultDelimiter;\n\n    // Increment `i` past modifier token.\n    if (repeat || optional) i++;\n\n    tokens.push({\n      name: name || key++,\n      prefix,\n      delimiter,\n      optional,\n      repeat,\n      pattern: pattern || `[^${escapeString(delimiter === defaultDelimiter ? delimiter : delimiter + defaultDelimiter)}]+?`,\n    });\n  }\n\n  if (path.length) tokens.push(path);\n\n  return tokens;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(str: string, options?: ParseOptions & TokensToFunctionOptions) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(tokens: Token[], options: TokensToFunctionOptions = {}): PathFunction<P> {\n  const reFlags = flags(options);\n  const {encode = (x: string) => x, validate = true} = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map(token => {\n    if (typeof token === 'object') {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n    return void 0;\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError(`Expected \"${token.name}\" to not repeat, but got an array`);\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(`Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(`Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n        }\n\n        path += token.prefix + segment;\n        continue;\n      }\n\n      if (token.optional) continue;\n\n      const typeOfMessage = token.repeat ? 'an array' : 'a string';\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (path: string) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(str: Path, options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(re: RegExp, keys: Key[], options: RegexpToFunctionOptions = {}): MatchFunction<P> {\n  const {decode = (x: string) => x} = options;\n\n  return function(pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const {0: path, index} = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.repeat) {\n        params[key.name] = m[i].split(key.delimiter).map(value => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return {path, index, params};\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: {sensitive?: boolean}) {\n  return options && options.sensitive ? '' : 'i';\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  delimiter: string;\n  optional: boolean;\n  repeat: boolean;\n  pattern: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  // Use a negative lookahead to match only capturing groups.\n  const groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (let i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: '',\n        delimiter: '',\n        optional: false,\n        repeat: false,\n        pattern: '',\n      });\n    }\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths: Array<string | RegExp>, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions): RegExp {\n  const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join('|')})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path: string, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string | string[];\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens: Token[], keys?: Key[], options: TokensToRegexpOptions = {}) {\n  const {strict, start = true, end = true, delimiter = DEFAULT_DELIMITER, encode = (x: string) => x} = options;\n  const endsWith = (typeof options.endsWith === 'string' ? options.endsWith.split('') : options.endsWith || [])\n    .map(escapeString)\n    .concat('$')\n    .join('|');\n  let route = start ? '^' : '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      route += escapeString(encode(token));\n    } else {\n      const capture = token.repeat ? `(?:${token.pattern})(?:${escapeString(token.delimiter)}(?:${token.pattern}))*` : token.pattern;\n\n      if (keys) keys.push(token);\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += `(${capture})?`;\n        } else {\n          route += `(?:${escapeString(token.prefix)}(${capture}))?`;\n        }\n      } else {\n        route += `${escapeString(token.prefix)}(${capture})`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `(?:${escapeString(delimiter)})?`;\n\n    route += endsWith === '$' ? '$' : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === 'string'\n        ? endToken[endToken.length - 1] === delimiter\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${escapeString(delimiter)}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${escapeString(delimiter)}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path: Path, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys);\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(path, keys, options);\n  }\n\n  return stringToRegexp(path, keys, options);\n}\n"],"file":"path-to-regexp.js"}