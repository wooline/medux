{"version":3,"file":"index.min.js","sources":["../../src/path-to-regexp.ts","../../src/matchPath.ts","../../src/index.ts"],"sourcesContent":["// fork from path-to-regexp 6.1.0\n// https://github.com/pillarjs/path-to-regexp\n\n/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type: 'OPEN' | 'CLOSE' | 'PATTERN' | 'NAME' | 'CHAR' | 'ESCAPED_CHAR' | 'MODIFIER' | 'END';\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === '*' || char === '+' || char === '?') {\n      tokens.push({type: 'MODIFIER', index: i, value: str[i++]});\n      continue;\n    }\n\n    if (char === '\\\\') {\n      tokens.push({type: 'ESCAPED_CHAR', index: i++, value: str[i++]});\n      continue;\n    }\n\n    if (char === '{') {\n      tokens.push({type: 'OPEN', index: i, value: str[i++]});\n      continue;\n    }\n\n    if (char === '}') {\n      tokens.push({type: 'CLOSE', index: i, value: str[i++]});\n      continue;\n    }\n\n    if (char === ':') {\n      let name = '';\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95 ||\n          // `.`\n          code === 46\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({type: 'NAME', index: i, value: name});\n      i = j;\n      continue;\n    }\n\n    if (char === '(') {\n      let count = 1;\n      let pattern = '';\n      let j = i + 1;\n\n      if (str[j] === '?') {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === '\\\\') {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === ')') {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === '(') {\n          count++;\n          if (str[j + 1] !== '?') {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({type: 'PATTERN', index: i, value: pattern});\n      i = j;\n      continue;\n    }\n\n    tokens.push({type: 'CHAR', index: i, value: str[i++]});\n  }\n\n  tokens.push({type: 'END', index: i, value: ''});\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const {prefixes = './'} = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || '/#?')}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = '';\n\n  const tryConsume = (type: LexToken['type']): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n    return undefined;\n  };\n\n  const mustConsume = (type: LexToken['type']): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const {type: nextType, index} = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = '';\n    let value: string | undefined;\n    // tslint:disable-next-line\n    while ((value = tryConsume('CHAR') || tryConsume('ESCAPED_CHAR'))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume('CHAR');\n    const name = tryConsume('NAME');\n    const pattern = tryConsume('PATTERN');\n\n    if (name || pattern) {\n      let prefix = char || '';\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = '';\n      }\n\n      if (path) {\n        result.push(path);\n        path = '';\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: '',\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume('MODIFIER') || '',\n      });\n      continue;\n    }\n\n    const value = char || tryConsume('ESCAPED_CHAR');\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = '';\n    }\n\n    const open = tryConsume('OPEN');\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume('NAME') || '';\n      const pattern = tryConsume('PATTERN') || '';\n      const suffix = consumeText();\n\n      mustConsume('CLOSE');\n\n      result.push({\n        name: name || (pattern ? key++ : ''),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume('MODIFIER') || '',\n      });\n      continue;\n    }\n\n    mustConsume('END');\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(str: string, options?: ParseOptions & TokensToFunctionOptions) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(tokens: Token[], options: TokensToFunctionOptions = {}): PathFunction<P> {\n  const reFlags = flags(options);\n  const {encode = (x: string) => x, validate = true} = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === 'object') {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n    return undefined;\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === '?' || token.modifier === '*';\n      const repeat = token.modifier === '*' || token.modifier === '+';\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(`Expected \"${token.name}\" to not repeat, but got an array`);\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(`Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(`Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? 'an array' : 'a string';\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (path: string) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(str: Path, options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(re: RegExp, keys: Key[], options: RegexpToFunctionOptions = {}): MatchFunction<P> {\n  const {decode = (x: string) => x} = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const {0: path, index} = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === '*' || key.modifier === '+') {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return {path, index, params};\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: {sensitive?: boolean}) {\n  return options && options.sensitive ? '' : 'i';\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  // Use a negative lookahead to match only capturing groups.\n  const groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (let i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: '',\n        suffix: '',\n        modifier: '',\n        pattern: '',\n      });\n    }\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths: Array<string | RegExp>, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join('|')})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path: string, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens: Token[], keys?: Key[], options: TokensToRegexpOptions = {}) {\n  const {strict = false, start = true, end = true, encode = (x: string) => x} = options;\n  const endsWith = `[${escapeString(options.endsWith || '')}]|$`;\n  const delimiter = `[${escapeString(options.delimiter || '/#?')}]`;\n  let route = start ? '^' : '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === '+' || token.modifier === '*') {\n            const mod = token.modifier === '*' ? '?' : '';\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiter}?`;\n\n    route += !options.endsWith ? '$' : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === 'string'\n        ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiter}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiter}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path: Path, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n","import {Key, PathFunction, compile, pathToRegexp} from './path-to-regexp';\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nexport function compileToPath(rule: string): PathFunction {\n  if (cache[rule]) {\n    return cache[rule];\n  }\n  const result = compile(rule);\n  if (cacheCount < cacheLimit) {\n    cache[rule] = result;\n    cacheCount++;\n  }\n  return result;\n}\nexport function compilePath(path: string, options: {end: boolean; strict: boolean; sensitive: boolean} = {end: false, strict: false, sensitive: false}): {regexp: RegExp; keys: Key[]} {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) {\n    return pathCache[path];\n  }\n\n  const keys: any[] = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = {regexp, keys};\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\ninterface MatchResult {\n  params: {[key: string]: string};\n  isExact: boolean;\n  path: string;\n  url: string;\n}\ninterface MatchPathOptions {\n  path?: string | string[];\n  strict?: boolean;\n  exact?: boolean;\n  sensitive?: boolean;\n}\n\nexport function matchPath(pathname: string, options: string | string[] | MatchPathOptions = {}): MatchResult {\n  if (typeof options === 'string' || Array.isArray(options)) {\n    options = {path: options};\n  }\n\n  const {path, exact = false, strict = false, sensitive = false} = options;\n\n  const paths = [].concat(path as any);\n\n  return paths.reduce((matched, path: string) => {\n    if (!path) return null;\n    if (matched) return matched;\n    if (path === '*') {\n      return {\n        path,\n        url: pathname,\n        isExact: true,\n        params: {},\n      };\n    }\n    const {regexp, keys} = compilePath(path, {\n      end: exact,\n      strict,\n      sensitive,\n    });\n    const match = regexp.exec(pathname);\n\n    if (!match) return null;\n\n    const [url, ...values] = match;\n    const isExact = pathname === url;\n\n    if (exact && !isExact) return null;\n\n    return {\n      path, // the path used to match\n      url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n      isExact, // whether or not we matched exactly\n      params: keys.reduce((memo: {[key: string]: any}, key: {name: string | number}, index: number) => {\n        memo[key.name] = values[index];\n        return memo;\n      }, {}),\n    };\n  }, null as any);\n}\n\nexport default matchPath;\n","import {DisplayViews, RouteData, config as coreConfig} from '@medux/core';\nimport {HistoryActions, LocationToRoute, MeduxLocation, RouteToLocation, TransformRoute} from '@medux/web';\nimport {compilePath, compileToPath, matchPath} from './matchPath';\n\nimport assignDeep from 'deep-extend';\n\nconst config = {\n  escape: true,\n  dateParse: true,\n  splitKey: 'q',\n  defaultRouteParams: {},\n};\nexport function setRouteConfig(conf: {escape?: boolean; dateParse?: boolean; splitKey?: string; defaultRouteParams?: {[moduleName: string]: any}}) {\n  conf.escape !== undefined && (config.escape = conf.escape);\n  conf.dateParse !== undefined && (config.dateParse = conf.dateParse);\n  conf.splitKey && (config.splitKey = conf.splitKey);\n  conf.defaultRouteParams && (config.defaultRouteParams = conf.defaultRouteParams);\n}\n\n// 排除默认路由参数，路由中如果参数值与默认参数相同可省去\nfunction excludeDefaultData(data: {[moduleName: string]: any}, def: {[moduleName: string]: any}, holde: boolean, views?: {[moduleName: string]: any}) {\n  const result: any = {};\n  Object.keys(data).forEach((moduleName) => {\n    let value = data[moduleName];\n    const defaultValue = def[moduleName];\n    if (value !== defaultValue) {\n      if (typeof value === typeof defaultValue && typeof value === 'object' && !Array.isArray(value)) {\n        value = excludeDefaultData(value, defaultValue, !!views && !views[moduleName]);\n      }\n      if (value !== undefined) {\n        result[moduleName] = value;\n      }\n    }\n  });\n\n  if (Object.keys(result).length === 0 && !holde) {\n    return undefined;\n  }\n  return result;\n}\n\n// 合并默认路由参数，如果路由中某参数没传，将用默认值替代，与上面方法互逆\n// function mergeDefaultData(data: {[moduleName: string]: any}, views: {[moduleName: string]: any}) {\n//   Object.keys(views).forEach(moduleName => {\n//     if (!data[moduleName]) {\n//       data[moduleName] = {};\n//     }\n//   });\n//   Object.keys(data).forEach(moduleName => {\n//     data[moduleName] = assignDeep({}, defaultRouteParams[moduleName], data[moduleName]);\n//   });\n// }\n\n// export const mergeDefaultParamsMiddleware: Middleware = () => (next: Function) => (action: any) => {\n//   if (action.type === ActionTypes.F_ROUTE_CHANGE) {\n//     const payload = getActionData<RouteState>(action);\n//     const params = mergeDefaultData(payload.data.views, payload.data.params, defaultRouteParams);\n//     action = {...action, payload: {...payload, data: {...payload.data, params}}};\n//   }\n//   return next(action);\n// };\n\nexport interface RouteConfig {\n  [path: string]: string | [string, RouteConfig];\n}\n\nconst ISO_DATE_FORMAT = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?(Z|[+-][01]\\d:[0-5]\\d)$/;\n\nfunction dateParse(prop: any, value: any) {\n  if (typeof value === 'string' && ISO_DATE_FORMAT.test(value)) {\n    return new Date(value);\n  }\n  return value;\n}\n// function getSearch(searchOrHash: string, key: string): string {\n//   if (searchOrHash.length < 4) {\n//     return '';\n//   }\n//   const reg = new RegExp(`[&?#]${key}=`);\n//   const str = searchOrHash.split(reg)[1];\n//   if (!str) {\n//     return '';\n//   }\n//   return str.split('&')[0];\n// }\n\n/*\n  将字符串变成 Data，因为 JSON 中没有 Date 类型，所以用正则表达式匹配自动转换\n*/\nfunction searchParse(search: string): {[moduleName: string]: {[key: string]: any} | undefined} {\n  if (!search) {\n    return {};\n  }\n  if (config.escape) {\n    search = unescape(search);\n  }\n  try {\n    return JSON.parse(search, config.dateParse ? dateParse : undefined);\n  } catch (error) {\n    return {};\n  }\n}\nfunction joinSearchString(arr: string[]): string {\n  const strs = [''];\n  for (let i = 0, k = arr.length; i < k; i++) {\n    strs.push(arr[i] || '');\n  }\n  return strs.join(`&${config.splitKey}=`);\n}\nfunction searchStringify(searchData: any): string {\n  if (typeof searchData !== 'object') {\n    return '';\n  }\n  const str = JSON.stringify(searchData);\n  if (str === '{}') {\n    return '';\n  }\n  if (config.escape) {\n    return escape(str);\n  } else {\n    return str;\n  }\n}\n\nfunction splitSearch(search: string) {\n  const reg = new RegExp(`[&?#]${config.splitKey}=[^&]*`, 'g');\n  const arr = search.match(reg);\n  let stackParams: {[moduleName: string]: {[key: string]: any} | undefined}[] = [];\n  if (arr) {\n    stackParams = arr.map((str) => {\n      return searchParse(str.split('=')[1]);\n    });\n  }\n  return stackParams;\n}\nfunction checkPathArgs(params: {[key: string]: string}): {[key: string]: any} {\n  const obj = {};\n  for (const key in params) {\n    if (params.hasOwnProperty(key)) {\n      const val = params[key];\n      const props = key.split('.');\n      if (props.length > 1) {\n        props.reduce((prev, cur, index, arr) => {\n          if (index === arr.length - 1) {\n            prev[cur] = val;\n          } else {\n            prev[cur] = {};\n          }\n          return prev[cur];\n        }, obj);\n      } else {\n        obj[key] = val;\n      }\n    }\n  }\n  return obj;\n}\nfunction pathnameParse(pathname: string, routeConfig: RouteConfig, paths: string[], args: {[moduleName: string]: {[key: string]: any} | undefined}) {\n  for (const rule in routeConfig) {\n    if (routeConfig.hasOwnProperty(rule)) {\n      const item = routeConfig[rule];\n      const [viewName, pathConfig] = typeof item === 'string' ? [item, null] : item;\n      const match = matchPath(pathname, {path: rule, exact: !pathConfig});\n      // const match = matchPath(pathname, {path: rule.replace(/\\$$/, ''), exact: rule.endsWith('$')});\n      if (match) {\n        paths.push(viewName);\n        const moduleName = viewName.split(coreConfig.VSP)[0];\n        const {params} = match;\n        if (params && Object.keys(params).length > 0) {\n          args[moduleName] = {...args[moduleName], ...checkPathArgs(params)};\n        }\n        if (pathConfig) {\n          pathnameParse(pathname, pathConfig, paths, args);\n        }\n        return;\n      }\n    }\n  }\n}\n\nfunction compileConfig(routeConfig: RouteConfig, parentAbsoluteViewName: string = '', viewToRule: {[viewName: string]: string} = {}, ruleToKeys: {[rule: string]: (string | number)[]} = {}) {\n  // ruleToKeys将每条rule中的params key解析出来\n  for (const rule in routeConfig) {\n    if (routeConfig.hasOwnProperty(rule)) {\n      if (!ruleToKeys[rule]) {\n        const {keys} = compilePath(rule, {end: true, strict: false, sensitive: false});\n        ruleToKeys[rule] = keys.reduce((prev: (string | number)[], cur) => {\n          prev.push(cur.name);\n          return prev;\n        }, []);\n      }\n      const item = routeConfig[rule];\n      const [viewName, pathConfig] = typeof item === 'string' ? [item, null] : item;\n      const absoluteViewName = parentAbsoluteViewName + '/' + viewName;\n      viewToRule[absoluteViewName] = rule;\n      if (pathConfig) {\n        compileConfig(pathConfig, absoluteViewName, viewToRule, ruleToKeys);\n      }\n    }\n  }\n  return {viewToRule, ruleToKeys};\n}\ntype DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};\n\n// type Params = RouteData['params'];\n\nexport interface RoutePayload<P> {\n  extend?: RouteData;\n  stackParams?: DeepPartial<P>[];\n  paths?: string[];\n}\n\nfunction assignRouteData(paths: string[], stackParams: {[moduleName: string]: any}[], args?: {[moduleName: string]: any}): RouteData {\n  if (!stackParams[0]) {\n    stackParams[0] = {};\n  }\n  if (args) {\n    stackParams[0] = assignDeep({}, args, stackParams[0]);\n  }\n  const firstStackParams = stackParams[0];\n  const views: DisplayViews = paths.reduce((prev: DisplayViews, cur) => {\n    const [moduleName, viewName] = cur.split(coreConfig.VSP);\n    if (viewName) {\n      if (!prev[moduleName]) {\n        prev[moduleName] = {};\n      }\n      prev[moduleName]![viewName] = true;\n      if (!firstStackParams[moduleName]) {\n        firstStackParams[moduleName] = {};\n      }\n    }\n    return prev;\n  }, {});\n  Object.keys(firstStackParams).forEach((moduleName) => {\n    firstStackParams[moduleName] = assignDeep({}, config.defaultRouteParams[moduleName], firstStackParams[moduleName]);\n  });\n  const params = assignDeep({}, ...stackParams);\n  Object.keys(params).forEach((moduleName) => {\n    if (!firstStackParams[moduleName]) {\n      params[moduleName] = assignDeep({}, config.defaultRouteParams[moduleName], params[moduleName]);\n    }\n  });\n  return {views, paths, params, stackParams};\n}\n\nexport function fillRouteData<R>(routePayload: RoutePayload<R>): RouteData {\n  const extend: RouteData = routePayload.extend || {views: {}, paths: [], stackParams: [], params: {}};\n  const stackParams = [...extend.stackParams];\n  if (routePayload.stackParams) {\n    routePayload.stackParams.forEach((item, index) => {\n      if (item) {\n        stackParams[index] = assignDeep({}, stackParams[index], item);\n      }\n    });\n  }\n  return assignRouteData(routePayload.paths || extend.paths, stackParams);\n}\nfunction extractHashData(params: {[moduleName: string]: any}) {\n  const searchParams: {[moduleName: string]: any} = {};\n  const hashParams: {[moduleName: string]: any} = {};\n  for (const moduleName in params) {\n    if (params[moduleName] && params.hasOwnProperty(moduleName)) {\n      const data = params[moduleName]!;\n      const keys = Object.keys(data);\n      if (keys.length > 0) {\n        keys.forEach((key) => {\n          if (key.startsWith('_')) {\n            if (!hashParams[moduleName]) {\n              hashParams[moduleName] = {};\n            }\n            hashParams[moduleName][key] = data[key];\n          } else {\n            if (!searchParams[moduleName]) {\n              searchParams[moduleName] = {};\n            }\n            searchParams[moduleName][key] = data[key];\n          }\n        });\n      } else {\n        searchParams[moduleName] = {};\n      }\n    }\n  }\n  return {\n    search: searchStringify(searchParams),\n    hash: searchStringify(hashParams),\n  };\n}\nexport function buildTransformRoute(routeConfig: RouteConfig): TransformRoute {\n  const {viewToRule, ruleToKeys} = compileConfig(routeConfig);\n\n  const locationToRoute: LocationToRoute = (location) => {\n    const paths: string[] = [];\n    const pathsArgs: {[moduleName: string]: {[key: string]: any}} = {};\n    pathnameParse(location.pathname, routeConfig, paths, pathsArgs);\n    const stackParams = splitSearch(location.search);\n    const hashStackParams = splitSearch(location.hash);\n    hashStackParams.forEach((item, index) => {\n      if (item) {\n        if (!stackParams[index]) {\n          stackParams[index] = {};\n        }\n        assignDeep(stackParams[index], item);\n      }\n    });\n    return assignRouteData(paths, stackParams, pathsArgs);\n  };\n  const routeToLocation: RouteToLocation = (routeData) => {\n    const {views, paths, params, stackParams} = routeData;\n    const firstStackParams = stackParams[0];\n    let pathname = '';\n    let firstStackParamsFilter: {[moduleName: string]: {[key: string]: any} | undefined};\n    if (paths.length > 0) {\n      // 将args深克隆，因为后面可能会删除path中使用到的变量\n      firstStackParamsFilter = assignDeep({}, firstStackParams);\n      paths.reduce((parentAbsoluteViewName, viewName, index) => {\n        const absoluteViewName = parentAbsoluteViewName + '/' + viewName;\n        const rule = viewToRule[absoluteViewName];\n        const moduleName = viewName.split(coreConfig.VSP)[0];\n        //最深的一个view可以决定pathname\n        if (index === paths.length - 1) {\n          // const toPath = compileToPath(rule.replace(/\\$$/, ''));\n          const toPath = compileToPath(rule);\n          const keys = ruleToKeys[rule] || [];\n          const args = keys.reduce((prev, cur) => {\n            if (typeof cur === 'string') {\n              const props = cur.split('.');\n              if (props.length) {\n                prev[cur] = props.reduce((p, c) => {\n                  return p[c];\n                }, params[moduleName]!);\n                return prev;\n              }\n            }\n            prev[cur] = params[moduleName]![cur];\n            return prev;\n          }, {});\n          pathname = toPath(args);\n        }\n        //pathname中传递的值可以不在params中重复传递\n        const keys = ruleToKeys[rule] || [];\n        keys.forEach((key) => {\n          if (typeof key === 'string') {\n            const props = key.split('.');\n            if (props.length) {\n              props.reduce((p, c, i) => {\n                if (i === props.length - 1) {\n                  delete p[c];\n                }\n                return p[c] || {};\n              }, firstStackParamsFilter[moduleName] || {});\n              return;\n            }\n          }\n          if (firstStackParamsFilter[moduleName]) {\n            delete firstStackParamsFilter[moduleName]![key];\n          }\n        });\n        return absoluteViewName;\n      }, '');\n    } else {\n      firstStackParamsFilter = firstStackParams;\n    }\n    //将带_前缀的变量放到hashData中\n    const arr = [...stackParams];\n    arr[0] = excludeDefaultData(firstStackParamsFilter, config.defaultRouteParams, false, views);\n    const searchStrings: string[] = [];\n    const hashStrings: string[] = [];\n    arr.forEach((params, index) => {\n      const {search, hash} = extractHashData(params);\n      search && (searchStrings[index] = search);\n      hash && (hashStrings[index] = hash);\n    });\n\n    return {\n      pathname,\n      search: '?' + joinSearchString(searchStrings).substr(1),\n      hash: '#' + joinSearchString(hashStrings).substr(1),\n    };\n  };\n  return {\n    locationToRoute,\n    routeToLocation,\n  };\n}\n//web中只有单个stack\nexport interface BrowserRoutePayload<P> {\n  extend?: RouteData;\n  params?: DeepPartial<P>;\n  paths?: string[];\n}\nexport function fillBrowserRouteData<R>(routePayload: BrowserRoutePayload<R>): RouteData {\n  const extend: RouteData = routePayload.extend || {views: {}, paths: [], stackParams: [], params: {}};\n  const stackParams = [...extend.stackParams];\n  if (routePayload.params) {\n    stackParams[0] = assignDeep({}, stackParams[0], routePayload.params);\n  }\n  return assignRouteData(routePayload.paths || extend.paths, stackParams);\n}\n\nfunction isBrowserRoutePayload(data: string | MeduxLocation | BrowserRoutePayload<any>): data is BrowserRoutePayload<any> {\n  return typeof data !== 'string' && !data['pathname'];\n}\nexport type BrowserHistoryActions<T> = HistoryActions<BrowserRoutePayload<T>>;\nexport function getBrowserRouteActions<T>(getBrowserHistoryActions: () => HistoryActions<RouteData>): BrowserHistoryActions<T> {\n  return {\n    push(data) {\n      if (isBrowserRoutePayload(data)) {\n        const args = fillBrowserRouteData(data);\n        getBrowserHistoryActions().push(args);\n      } else {\n        getBrowserHistoryActions().push(data);\n      }\n    },\n    replace(data) {\n      if (isBrowserRoutePayload(data)) {\n        const args = fillBrowserRouteData(data);\n        getBrowserHistoryActions().replace(args);\n      } else {\n        getBrowserHistoryActions().replace(data);\n      }\n    },\n    go(n) {\n      getBrowserHistoryActions().go(n);\n    },\n    goBack() {\n      getBrowserHistoryActions().goBack();\n    },\n    goForward() {\n      getBrowserHistoryActions().goForward();\n    },\n  };\n}\nexport interface ToBrowserUrl<T> {\n  (routeOptions: BrowserRoutePayload<T>): string;\n  (pathname: string, search: string, hash: string): string;\n}\nexport function buildToBrowserUrl(getTransformRoute: () => TransformRoute): ToBrowserUrl<any> {\n  function toUrl(routeOptions: BrowserRoutePayload<any>): string;\n  function toUrl(pathname: string, search: string, hash: string): string;\n  function toUrl(...args: any[]): string {\n    if (args.length === 1) {\n      const location = getTransformRoute().routeToLocation(fillBrowserRouteData(args[0]));\n      args = [location.pathname, location.search, location.hash];\n    }\n    const [pathname, search, hash] = args as [string, string, string];\n    let url = pathname;\n    if (search) {\n      url += search;\n    }\n    if (hash) {\n      url += hash;\n    }\n    return url;\n  }\n  return toUrl;\n}\n\n// export function buildTransformRoute(routeConfig: RouteConfig): TransformRoute {\n//   const {viewToRule, ruleToKeys} = compileConfig(routeConfig);\n//   const locationToRoute: LocationToRoute = location => {\n//     const paths: string[] = [];\n//     const {stackParams, params} = splitSearch(location.search);\n//     //算出paths，并将path参数提取出来并入searchParams中\n//     pathnameParse(location.pathname, routeConfig, paths, params);\n//     const views: DisplayViews = paths.reduce((prev: DisplayViews, cur) => {\n//       const [moduleName, viewName] = cur.split(coreConfig.VSP);\n//       if (viewName) {\n//         if (!prev[moduleName]) {\n//           prev[moduleName] = {};\n//         }\n//         prev[moduleName]![viewName] = true;\n//       }\n//       return prev;\n//     }, {});\n//     const {stackParams: hashStackParams, params: hashParams} = splitSearch(location.hash);\n//     //将hash参数并入params中\n//     assignDeep(params, hashParams);\n//     hashStackParams.forEach((item, index) => {\n//       item && assignDeep(stackParams[index], item);\n//     });\n//     mergeDefaultData(params, views);\n//     return {paths, params, views, stackParams};\n//   };\n//   const routeToLocation: RouteToLocation = routeData => {\n//     const {paths, params, stackParams} = routeData;\n//     const mainStackParams = stackParams[0] || {};\n//     let pathname = '';\n//     let args: {[moduleName: string]: {[key: string]: any} | undefined};\n//     if (paths.length > 0) {\n//       args = {};\n//       // 将args二层克隆params，因为后面可能会删除path中使用到的变量\n//       for (const moduleName in mainStackParams) {\n//         if (mainStackParams[moduleName] && mainStackParams.hasOwnProperty(moduleName)) {\n//           args[moduleName] = {...mainStackParams[moduleName]};\n//         }\n//       }\n//       paths.reduce((parentAbsoluteViewName, viewName, index) => {\n//         const absoluteViewName = parentAbsoluteViewName + '/' + viewName;\n//         const rule = viewToRule[absoluteViewName];\n//         const moduleName = viewName.split(coreConfig.VSP)[0];\n//         //最深的一个view可以决定pathname\n//         if (index === paths.length - 1) {\n//           // const toPath = compileToPath(rule.replace(/\\$$/, ''));\n//           const toPath = compileToPath(rule);\n//           pathname = toPath(params[moduleName]);\n//         }\n//         //pathname中传递的值可以不在params中重复传递\n//         const keys = ruleToKeys[rule] || [];\n//         keys.forEach(key => {\n//           if (args[moduleName]) {\n//             delete args[moduleName]![key];\n//           }\n//         });\n//         return absoluteViewName;\n//       }, '');\n//     } else {\n//       args = mainStackParams;\n//     }\n//     //将带_前缀的变量放到hashData中\n//     const searchData = {};\n//     const hashData = {};\n//     for (const moduleName in args) {\n//       if (args[moduleName] && args.hasOwnProperty(moduleName)) {\n//         const data = args[moduleName]!;\n//         const keys = Object.keys(data);\n//         if (keys.length > 0) {\n//           keys.forEach(key => {\n//             if (key.startsWith('_')) {\n//               if (!hashData[moduleName]) {\n//                 hashData[moduleName] = {};\n//               }\n//               hashData[moduleName][key] = data[key];\n//             } else {\n//               if (!searchData[moduleName]) {\n//                 searchData[moduleName] = {};\n//               }\n//               searchData[moduleName][key] = data[key];\n//             }\n//           });\n//         }\n//       }\n//     }\n//     return {\n//       pathname,\n//       search: searchStringify(excludeDefaultData(searchData, defaultRouteParams)),\n//       hash: searchStringify(excludeDefaultData(hashData, defaultRouteParams)),\n//     };\n//   };\n//   return {\n//     locationToRoute,\n//     routeToLocation,\n//   };\n// }\n\n/**\n '/:articleType/:articleId/comments/:itemId'\n www.aa.com/photos/1/comments/23?p={}&p=\n\n paths:[\"app.Main\", \"photos.detail\", \"comments.detail\"]\n params:{app:{},photos:{itemid:1,searchList:{page:1,pageSize:10},_listkey:222222},comments:{articleType:photos,articleId:1,itemid:23,searchList:{page:2,pageSize:10},_listkey:222222}}\n stackParams:[{app:{}}, {photos:{itemid:1,searchList:{page:1,pageSize:10},_listkey:222222}}, {comments:{articleType:photos,articleId:1,itemid:23,searchList:{page:2,pageSize:10},_listkey:222222}}]\n stackParams:[{app:{},photos:{itemid:1,searchList:{page:1,pageSize:10},_listkey:222222},comments:{articleType:photos,articleId:1,itemid:23,searchList:{page:2,pageSize:10},_listkey:222222}}]\n\n web: www.aa.com/photos/1/comments/23?p={comments:{searchList:{page:2}}}#p={photos:{_listkey:222222}, comments:{_listkey:222222}}\n\n rn: www.aa.com/photos/1/comments/23?p={app:{}}&p={photos:{}}&p={comments:{searchList:{page:2}}}#p={}&p={photos:{_listkey:222222}}&p={comments:{_listkey:222222}}\n\n routeData -> location\n1.根据paths得到匹配表达式：'/:articleType/:articleId/comments/:itemId'\n2.根据params填充表达式得到：www.aa.com/photos/1/comments/23\n3.将params中带_的提取为hash\n不作缩减将得到：\nwww.aa.com/photos/1/comments/23?\np={app:{}}&\np={photos:{itemid:1,searchList:{page:1,pageSize:10}}}&\np={comments:{articleType:photos,articleId:1,itemid:23,searchList:{page:2,pageSize:10}}}\n#\np={}&\np={photos:{_listkey:222222}}\np={comments:{_listkey:222222}}\n4.缩\b减默认值：\nwww.aa.com/photos/1/comments/23?\np={app:{}}&\np={photos:{itemid:1}}&\np={comments:{articleType:photos,articleId:1,itemid:23,searchList:{page:2}}}\n#\np={}&\np={photos:{_listkey:222222}}\np={comments:{_listkey:222222}}\n5.缩减路径传参\nwww.aa.com/photos/1/comments/23?\np={app:{}}&\np={photos:{}}&\np={comments:{searchList:{page:2}}}\n#\np={}&\np={photos:{_listkey:222222}}\np={comments:{_listkey:222222}}\n\n\n\n location->routeData\n1.解析出paths、views、pathArgs\n2.\n\n */\n"],"names":["parse","str","options","tokens","i","length","char","push","type","index","value","count","pattern","j","TypeError","name","code","charCodeAt","lexer","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","compile","reFlags","flags","encode","x","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","typeOfMessage","String","tokensToFunction","replace","sensitive","stringToRegexp","keys","strict","start","end","endsWith","route","mod","endToken","isEndDelimited","tokensToRegexp","pathToRegexp","groups","source","match","regexpToRegexp","paths","parts","join","arrayToRegexp","cache","cacheCount","compilePath","cacheKey","pathCache","regexp","matchPath","pathname","exact","concat","reduce","matched","url","isExact","params","exec","values","memo","config","escape","dateParse","splitKey","defaultRouteParams","ISO_DATE_FORMAT","prop","Date","joinSearchString","arr","strs","k","searchStringify","searchData","JSON","stringify","splitSearch","search","reg","stackParams","unescape","error","searchParse","split","checkPathArgs","obj","hasOwnProperty","val","props","prev","cur","assignRouteData","args","assignDeep","firstStackParams","views","coreConfig","VSP","moduleName","viewName","Object","forEach","fillBrowserRouteData","routePayload","extend","isBrowserRoutePayload","getTransformRoute","location","routeToLocation","hash","routeConfig","compileConfig","parentAbsoluteViewName","viewToRule","ruleToKeys","rule","item","pathConfig","absoluteViewName","locationToRoute","pathsArgs","pathnameParse","routeData","firstStackParamsFilter","toPath","compileToPath","p","c","excludeDefaultData","def","holde","defaultValue","searchStrings","hashStrings","searchParams","hashParams","startsWith","extractHashData","substr","getBrowserHistoryActions","go","n","goBack","goForward","conf"],"mappings":"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"}