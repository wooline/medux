{"version":3,"sources":["../../src/matchPath.ts"],"names":["cache","cacheLimit","cacheCount","compileToPath","rule","result","pathToRegexp","compile","compilePath","path","options","end","strict","sensitive","cacheKey","pathCache","keys","regexp","matchPath","pathname","Array","isArray","exact","paths","concat","reduce","matched","url","isExact","params","match","exec","values","memo","key","index","name"],"mappings":"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","sourcesContent":["import pathToRegexp, {Key, PathFunction} from './path-to-regexp.js';\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nexport function compileToPath(rule: string): PathFunction {\n  if (cache[rule]) {\n    return cache[rule];\n  }\n  const result = pathToRegexp.compile(rule);\n  if (cacheCount < cacheLimit) {\n    cache[rule] = result;\n    cacheCount++;\n  }\n  return result;\n}\nexport function compilePath(path: string, options: {end: boolean; strict: boolean; sensitive: boolean} = {end: false, strict: false, sensitive: false}): {regexp: RegExp; keys: Key[]} {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) {\n    return pathCache[path];\n  }\n\n  const keys: any[] = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = {regexp, keys};\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\ninterface MatchResult {\n  params: {[key: string]: string};\n  isExact: boolean;\n  path: string;\n  url: string;\n}\ninterface MatchPathOptions {\n  path?: string | string[];\n  strict?: boolean;\n  exact?: boolean;\n  sensitive?: boolean;\n}\n\nexport function matchPath(pathname: string, options: string | string[] | MatchPathOptions = {}): MatchResult {\n  if (typeof options === 'string' || Array.isArray(options)) {\n    options = {path: options};\n  }\n\n  const {path, exact = false, strict = false, sensitive = false} = options;\n\n  const paths = [].concat(path as any);\n\n  return paths.reduce(\n    (matched, path: string) => {\n      if (!path) return null;\n      if (matched) return matched;\n      if (path === '*') {\n        return {\n          path,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n      }\n      const {regexp, keys} = compilePath(path, {\n        end: exact,\n        strict,\n        sensitive,\n      });\n      const match = regexp.exec(pathname);\n\n      if (!match) return null;\n\n      const [url, ...values] = match;\n      const isExact = pathname === url;\n\n      if (exact && !isExact) return null;\n\n      return {\n        path, // the path used to match\n        url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n        isExact, // whether or not we matched exactly\n        params: keys.reduce((memo: {[key: string]: any}, key: {name: string | number}, index: number) => {\n          memo[key.name] = values[index];\n          return memo;\n        }, {}),\n      };\n    },\n    null as any\n  );\n}\n\nexport default matchPath;\n"],"file":"matchPath.js"}