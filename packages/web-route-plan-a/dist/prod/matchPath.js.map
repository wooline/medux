{"version":3,"sources":["../../src/matchPath.ts"],"names":["pathToRegexp","cache","cacheLimit","cacheCount","compileToPath","rule","result","compile","compilePath","path","options","end","strict","sensitive","cacheKey","pathCache","keys","regexp","matchPath","pathname","Array","isArray","exact","paths","concat","reduce","matched","url","isExact","params","match","exec","values","memo","key","index","name"],"mappings":"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","sourcesContent":["import pathToRegexp, {Key, PathFunction} from 'path-to-regexp';\n\nconst cache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nexport function compileToPath(rule: string): PathFunction {\n  if (cache[rule]) {\n    return cache[rule];\n  }\n  const result = pathToRegexp.compile(rule);\n  if (cacheCount < cacheLimit) {\n    cache[rule] = result;\n    cacheCount++;\n  }\n  return result;\n}\nexport function compilePath(path: string, options: {end: boolean; strict: boolean; sensitive: boolean} = {end: false, strict: false, sensitive: false}): {regexp: RegExp; keys: Key[]} {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\n\n  if (pathCache[path]) {\n    return pathCache[path];\n  }\n\n  const keys: any[] = [];\n  const regexp = pathToRegexp(path, keys, options);\n  const result = {regexp, keys};\n\n  if (cacheCount < cacheLimit) {\n    pathCache[path] = result;\n    cacheCount++;\n  }\n\n  return result;\n}\ninterface MatchResult {\n  params: {[key: string]: string};\n  isExact: boolean;\n  path: string;\n  url: string;\n}\ninterface MatchPathOptions {\n  path?: string | string[];\n  strict?: boolean;\n  exact?: boolean;\n  sensitive?: boolean;\n}\n\nexport function matchPath(pathname: string, options: string | string[] | MatchPathOptions = {}): MatchResult {\n  if (typeof options === 'string' || Array.isArray(options)) {\n    options = {path: options};\n  }\n\n  const {path, exact = false, strict = false, sensitive = false} = options;\n\n  const paths = [].concat(path as any);\n\n  return paths.reduce(\n    (matched, path: string) => {\n      if (!path) return null;\n      if (matched) return matched;\n      if (path === '*') {\n        return {\n          path,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n      }\n      const {regexp, keys} = compilePath(path, {\n        end: exact,\n        strict,\n        sensitive,\n      });\n      const match = regexp.exec(pathname);\n\n      if (!match) return null;\n\n      const [url, ...values] = match;\n      const isExact = pathname === url;\n\n      if (exact && !isExact) return null;\n\n      return {\n        path, // the path used to match\n        url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n        isExact, // whether or not we matched exactly\n        params: keys.reduce((memo: {[key: string]: any}, key: {name: string | number}, index: number) => {\n          memo[key.name] = values[index];\n          return memo;\n        }, {}),\n      };\n    },\n    null as any\n  );\n}\n\nexport default matchPath;\n"],"file":"matchPath.js"}