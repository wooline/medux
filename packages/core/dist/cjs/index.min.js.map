{"version":3,"file":"index.min.js","sources":["../../src/sprite.ts","../../src/basic.ts","../../src/actions.ts","../../src/store.ts","../../src/module.ts"],"sourcesContent":["export const TaskCountEvent = 'TaskCountEvent';\n\nexport enum LoadingState {\n  Start = 'Start',\n  Stop = 'Stop',\n  Depth = 'Depth',\n}\n\nexport class PEvent {\n  public readonly target: PDispatcher = null as any;\n  public readonly currentTarget: PDispatcher = null as any;\n\n  public constructor(public readonly name: string, public readonly data?: any, public bubbling: boolean = false) {}\n\n  public setTarget(target: PDispatcher) {\n    (this as any).target = target;\n  }\n\n  public setCurrentTarget(target: PDispatcher) {\n    (this as any).currentTarget = target;\n  }\n}\n\nexport class PDispatcher {\n  protected readonly storeHandlers: {\n    [key: string]: ((e: PEvent) => void)[];\n  } = {};\n\n  public constructor(public readonly parent?: PDispatcher | undefined) {}\n\n  public addListener(ename: string, handler: (e: PEvent) => void): this {\n    let dictionary = this.storeHandlers[ename];\n    if (!dictionary) {\n      this.storeHandlers[ename] = dictionary = [];\n    }\n    dictionary.push(handler);\n    return this;\n  }\n\n  public removeListener(ename?: string, handler?: (e: PEvent) => void): this {\n    if (!ename) {\n      Object.keys(this.storeHandlers).forEach((key) => {\n        delete this.storeHandlers[key];\n      });\n    } else {\n      const handlers = this.storeHandlers;\n      if (handlers.propertyIsEnumerable(ename)) {\n        const dictionary = handlers[ename];\n        if (!handler) {\n          delete handlers[ename];\n        } else {\n          const n = dictionary.indexOf(handler);\n          if (n > -1) {\n            dictionary.splice(n, 1);\n          }\n          if (dictionary.length === 0) {\n            delete handlers[ename];\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  public dispatch(evt: PEvent): this {\n    if (!evt.target) {\n      evt.setTarget(this);\n    }\n    evt.setCurrentTarget(this);\n    const dictionary = this.storeHandlers[evt.name];\n    if (dictionary) {\n      for (let i = 0, k = dictionary.length; i < k; i++) {\n        dictionary[i](evt);\n      }\n    }\n    if (this.parent && evt.bubbling) {\n      this.parent.dispatch(evt);\n    }\n    return this;\n  }\n  public setParent(parent?: PDispatcher): this {\n    (this as any).parent = parent;\n    return this;\n  }\n}\n\nexport class TaskCounter extends PDispatcher {\n  public readonly list: {promise: Promise<any>; note: string}[] = [];\n  private ctimer: NodeJS.Timeout | null = null;\n  public constructor(public deferSecond: number) {\n    super();\n  }\n  public addItem(promise: Promise<any>, note: string = ''): Promise<any> {\n    if (!this.list.some((item) => item.promise === promise)) {\n      this.list.push({promise, note});\n      promise.then(\n        () => this.completeItem(promise),\n        () => this.completeItem(promise)\n      );\n\n      if (this.list.length === 1) {\n        this.dispatch(new PEvent(TaskCountEvent, LoadingState.Start));\n        this.ctimer = setTimeout(() => {\n          this.ctimer = null;\n          if (this.list.length > 0) {\n            this.dispatch(new PEvent(TaskCountEvent, LoadingState.Depth));\n          }\n        }, this.deferSecond * 1000);\n      }\n    }\n    return promise;\n  }\n  private completeItem(promise: Promise<any>): this {\n    const i = this.list.findIndex((item) => item.promise === promise);\n    if (i > -1) {\n      this.list.splice(i, 1);\n      if (this.list.length === 0) {\n        if (this.ctimer) {\n          clearTimeout(this.ctimer);\n          this.ctimer = null;\n        }\n\n        this.dispatch(new PEvent(TaskCountEvent, LoadingState.Stop));\n      }\n    }\n    return this;\n  }\n}\n","/*global global:true process:true*/\nimport {LoadingState, TaskCountEvent, TaskCounter} from './sprite';\n\nimport {ModuleGetter} from './module';\n\n// export const root: {__REDUX_DEVTOOLS_EXTENSION__?: any; __REDUX_DEVTOOLS_EXTENSION__OPTIONS?: any; onerror: any; onunhandledrejection: any} = ((typeof self == 'object' &&\n//   self.self === self &&\n//   self) ||\n//   (typeof global == 'object' && global.global === global && global) ||\n//   this) as any;\n\nconst loadings: {[moduleName: string]: TaskCounter} = {};\n\nlet depthTime = 2;\n\nexport function setLoadingDepthTime(second: number) {\n  depthTime = second;\n}\nexport function setLoading<T extends Promise<any>>(item: T, moduleName: string = MetaData.appModuleName, group: string = 'global'): T {\n  if (MetaData.isServer) {\n    return item;\n  }\n  const key = moduleName + config.NSP + group;\n  if (!loadings[key]) {\n    loadings[key] = new TaskCounter(depthTime);\n    loadings[key].addListener(TaskCountEvent, (e) => {\n      const store = MetaData.clientStore;\n      if (store) {\n        const actions = MetaData.actionCreatorMap[moduleName][ActionTypes.MLoading];\n        const action = actions({[group]: e.data});\n        store.dispatch(action);\n      }\n    });\n  }\n  loadings[key].addItem(item);\n  return item;\n}\n\nexport const config: {\n  NSP: string;\n  VSP: string;\n  MSP: string;\n} = {\n  NSP: '/',\n  VSP: '.',\n  MSP: ',',\n};\nexport function setConfig(_config: {NSP?: string; VSP?: string; MSP?: string}) {\n  _config.NSP && (config.NSP = _config.NSP);\n  _config.VSP && (config.VSP = _config.VSP);\n  _config.MSP && (config.MSP = _config.MSP);\n}\nexport const MetaData: {\n  isServer: boolean;\n  isDev: boolean;\n  actionCreatorMap: ActionCreatorMap;\n  clientStore: ModelStore;\n  appModuleName: string;\n  moduleGetter: ModuleGetter;\n} = {\n  isServer: typeof global !== 'undefined' && typeof window === 'undefined',\n  isDev: process.env.NODE_ENV !== 'production',\n  actionCreatorMap: null as any,\n  clientStore: null as any,\n  appModuleName: null as any,\n  moduleGetter: null as any,\n};\n\nexport const ActionTypes = {\n  MLoading: 'Loading',\n  MInit: 'Init',\n  MRouteParams: 'RouteParams',\n  Error: `medux${config.NSP}Error`,\n  RouteChange: `medux${config.NSP}RouteChange`,\n};\nexport const client: Window | undefined = MetaData.isServer ? undefined : typeof window === 'undefined' ? (global as any) : window;\nexport interface ActionCreatorMap {\n  [moduleName: string]: ActionCreatorList;\n}\nexport interface ActionCreatorList {\n  [actionName: string]: ActionCreator;\n}\nexport type ActionCreator = (...args: any[]) => Action;\ninterface Store {\n  dispatch(action: Action): Action | Promise<void>;\n  getState(): {[key: string]: any};\n  subscribe(listener: () => void): void;\n}\nexport interface ModelStore extends Store {\n  _medux_: {\n    reducerMap: ReducerMap;\n    effectMap: EffectMap;\n    injectedModules: {[moduleName: string]: boolean};\n    currentViews: CurrentViews;\n    beforeState: StoreState;\n    prevState: StoreState;\n    currentState: StoreState;\n  };\n}\nexport interface RouteData {\n  views: DisplayViews;\n  params: {[moduleName: string]: {[key: string]: any} | undefined};\n  paths: string[];\n  stackParams: {[moduleName: string]: {[key: string]: any} | undefined}[];\n}\nexport interface RouteState<L = any> {\n  location: L;\n  data: RouteData;\n}\nexport type StoreState = {\n  [moduleName: string]: BaseModelState;\n} & {route: RouteState};\n\nexport interface DisplayViews {\n  [moduleName: string]: {[viewName: string]: boolean | undefined} | undefined;\n}\nexport interface CurrentViews {\n  [moduleName: string]: {[viewName: string]: {[key: string]: boolean}};\n}\nexport interface ReducerHandler extends ActionHandler {\n  (payload: any): BaseModelState;\n}\nexport interface EffectHandler extends ActionHandler {\n  (payload: any, prevRootState: StoreState): Promise<any>;\n}\nexport interface ActionHandlerList {\n  [actionName: string]: ActionHandler;\n}\nexport interface ActionHandlerMap {\n  [actionName: string]: {[moduleName: string]: ActionHandler};\n}\nexport interface ReducerMap extends ActionHandlerMap {\n  [actionName: string]: {[moduleName: string]: ReducerHandler};\n}\nexport interface EffectMap extends ActionHandlerMap {\n  [actionName: string]: {[moduleName: string]: EffectHandler};\n}\nexport interface Action {\n  type: string;\n  priority?: string[];\n  payload?: any[];\n}\nexport interface ActionHandler {\n  __actionName__: string;\n  __isReducer__?: boolean;\n  __isEffect__?: boolean;\n  __isHandler__?: boolean;\n  __decorators__?: [(action: Action, moduleName: string, effectResult: Promise<any>) => any, null | ((status: 'Rejected' | 'Resolved', beforeResult: any, effectResult: any) => void)][];\n  __decoratorResults__?: any[];\n  (payload?: any): any;\n}\nexport interface BaseModelState<R = {[key: string]: any}> {\n  isModule?: boolean;\n  routeParams?: R;\n  loading?: {\n    [key: string]: LoadingState;\n  };\n}\n\nexport function isPromise(data: any): data is Promise<any> {\n  return typeof data === 'object' && typeof data['then'] === 'function';\n}\nexport function getClientStore() {\n  return MetaData.clientStore;\n}\nexport function isServer(): boolean {\n  return MetaData.isServer;\n}\nexport function reducer(target: any, key: string, descriptor: PropertyDescriptor) {\n  if (!key && !descriptor) {\n    key = target.key;\n    descriptor = target.descriptor;\n  }\n  const fun = descriptor.value as ActionHandler;\n  fun.__actionName__ = key;\n  fun.__isReducer__ = true;\n  descriptor.enumerable = true;\n  return target.descriptor === descriptor ? target : descriptor;\n}\n\nexport function effect(loadingForGroupName?: string | null, loadingForModuleName?: string) {\n  if (loadingForGroupName === undefined) {\n    loadingForGroupName = 'global';\n    loadingForModuleName = MetaData.appModuleName;\n  }\n  return (target: any, key: string, descriptor: PropertyDescriptor) => {\n    if (!key && !descriptor) {\n      key = target.key;\n      descriptor = target.descriptor;\n    }\n    const fun = descriptor.value as ActionHandler;\n    fun.__actionName__ = key;\n    fun.__isEffect__ = true;\n    descriptor.enumerable = true;\n    if (loadingForGroupName) {\n      const before = (curAction: Action, moduleName: string, promiseResult: Promise<any>) => {\n        if (!MetaData.isServer) {\n          if (!loadingForModuleName) {\n            loadingForModuleName = moduleName;\n          }\n          setLoading(promiseResult, loadingForModuleName, loadingForGroupName as string);\n        }\n      };\n      if (!fun.__decorators__) {\n        fun.__decorators__ = [];\n      }\n      fun.__decorators__.push([before, null]);\n    }\n    return target.descriptor === descriptor ? target : descriptor;\n  };\n}\nexport function logger(\n  before: (action: Action, moduleName: string, promiseResult: Promise<any>) => void,\n  after: null | ((status: 'Rejected' | 'Resolved', beforeResult: any, effectResult: any) => void)\n) {\n  return (target: any, key: string, descriptor: PropertyDescriptor) => {\n    if (!key && !descriptor) {\n      key = target.key;\n      descriptor = target.descriptor;\n    }\n    const fun: ActionHandler = descriptor.value;\n    if (!fun.__decorators__) {\n      fun.__decorators__ = [];\n    }\n    fun.__decorators__.push([before, after]);\n  };\n}\nexport function delayPromise(second: number) {\n  return (target: any, key: string, descriptor: PropertyDescriptor) => {\n    if (!key && !descriptor) {\n      key = target.key;\n      descriptor = target.descriptor;\n    }\n    const fun = descriptor.value;\n    descriptor.value = (...args: any[]) => {\n      const delay = new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(true);\n        }, second * 1000);\n      });\n      return Promise.all([delay, fun.apply(target, args)]).then((items) => {\n        return items[1];\n      });\n    };\n  };\n}\nexport function isProcessedError(error: any): boolean | undefined {\n  if (typeof error !== 'object' || error.meduxProcessed === undefined) {\n    return undefined;\n  } else {\n    return !!error.meduxProcessed;\n  }\n}\nexport function setProcessedError(error: any, meduxProcessed: boolean): {meduxProcessed: boolean; [key: string]: any} {\n  if (typeof error === 'object') {\n    error.meduxProcessed = meduxProcessed;\n    return error;\n  } else {\n    return {\n      meduxProcessed,\n      error,\n    };\n  }\n}\nfunction bindThis(fun: ActionHandler, thisObj: any) {\n  const newFun = fun.bind(thisObj);\n  Object.keys(fun).forEach((key) => {\n    newFun[key] = fun[key];\n  });\n\n  return newFun as ActionHandler;\n}\nfunction transformAction(actionName: string, action: ActionHandler, listenerModule: string, actionHandlerMap: ActionHandlerMap) {\n  if (!actionHandlerMap[actionName]) {\n    actionHandlerMap[actionName] = {};\n  }\n  if (actionHandlerMap[actionName][listenerModule]) {\n    throw new Error(`Action duplicate or conflict : ${actionName}.`);\n  }\n  actionHandlerMap[actionName][listenerModule] = action;\n}\n\nfunction addModuleActionCreatorList(moduleName: string, actionName: string) {\n  const actions = MetaData.actionCreatorMap[moduleName];\n  if (!actions[actionName]) {\n    actions[actionName] = (...payload: any[]) => ({type: moduleName + config.NSP + actionName, payload});\n  }\n}\nexport function injectActions(store: ModelStore, moduleName: string, handlers: ActionHandlerList) {\n  for (const actionNames in handlers) {\n    if (typeof handlers[actionNames] === 'function') {\n      let handler = handlers[actionNames];\n      if (handler.__isReducer__ || handler.__isEffect__) {\n        handler = bindThis(handler, handlers);\n        actionNames.split(config.MSP).forEach((actionName) => {\n          actionName = actionName.trim().replace(new RegExp(`^this[${config.NSP}]`), `${moduleName}${config.NSP}`);\n          const arr = actionName.split(config.NSP);\n          if (arr[1]) {\n            handler.__isHandler__ = true;\n            transformAction(actionName, handler, moduleName, handler.__isEffect__ ? store._medux_.effectMap : store._medux_.reducerMap);\n          } else {\n            handler.__isHandler__ = false;\n            transformAction(moduleName + config.NSP + actionName, handler, moduleName, handler.__isEffect__ ? store._medux_.effectMap : store._medux_.reducerMap);\n            addModuleActionCreatorList(moduleName, actionName);\n          }\n        });\n      }\n    }\n  }\n  return MetaData.actionCreatorMap[moduleName];\n}\n","import {ActionTypes, RouteState, config} from './basic';\n\nexport function errorAction(error: any) {\n  return {\n    type: ActionTypes.Error,\n    payload: [error],\n  };\n}\n\nexport function routeChangeAction(route: RouteState) {\n  return {\n    type: ActionTypes.RouteChange,\n    payload: [route],\n  };\n}\n\nexport function routeParamsAction(moduleName: string, params: any) {\n  return {\n    type: `${moduleName}${config.NSP}${ActionTypes.MRouteParams}`,\n    payload: [params],\n  };\n}\n","import {Action, ActionTypes, MetaData, ModelStore, RouteData, RouteState, StoreState, client, config, isProcessedError, isPromise, setProcessedError} from './basic';\nimport {Middleware, ReducersMapObject, StoreEnhancer, applyMiddleware, compose, createStore} from 'redux';\nimport {Module, ModuleGetter} from './module';\nimport {errorAction, routeChangeAction, routeParamsAction} from './actions';\n\nfunction isPromiseModule(module: Module | Promise<Module>): module is Promise<Module> {\n  return typeof module['then'] === 'function';\n}\n\nexport function loadModel<MG extends ModuleGetter>(moduleName: Extract<keyof MG, string>, store: ModelStore, options?: any): void | Promise<void> {\n  const hasInjected = store._medux_.injectedModules[moduleName];\n  if (!hasInjected) {\n    const moduleGetter = MetaData.moduleGetter;\n    const result = moduleGetter[moduleName]();\n    if (isPromiseModule(result)) {\n      return result.then((module) => {\n        moduleGetter[moduleName] = (() => module) as any;\n        return module.default.model(store, options);\n      });\n    } else {\n      return result.default.model(store, options);\n    }\n  }\n}\n\nexport function getActionData(action: Action): any[] {\n  return Array.isArray(action.payload) ? action.payload : [];\n}\nexport interface HistoryProxy<L = any> {\n  initialized: boolean;\n  getLocation(): L;\n  subscribe(listener: (location: L) => void): void;\n  locationToRouteData(location: L): RouteData;\n  equal(a: L, b: L): boolean;\n  patch(location: L, routeData: RouteData): void;\n}\n\nfunction bindHistory<L>(store: ModelStore, history: HistoryProxy<L>) {\n  let inTimeTravelling = false;\n  const handleLocationChange = (location: L) => {\n    if (!inTimeTravelling) {\n      const {route} = store.getState() as StoreState;\n      if (route) {\n        if (history.equal(route.location, location)) {\n          return;\n        }\n      }\n      const data = history.locationToRouteData(location);\n      store.dispatch(routeChangeAction({location, data}));\n    } else {\n      inTimeTravelling = false;\n    }\n  };\n  history.subscribe(handleLocationChange);\n  store.subscribe(() => {\n    if (history.initialized) {\n      const storeRouteState = (store.getState() as StoreState).route;\n      if (!history.equal(storeRouteState.location, history.getLocation())) {\n        inTimeTravelling = true;\n        history.patch(storeRouteState.location, storeRouteState.data);\n      }\n    }\n  });\n  history.initialized && handleLocationChange(history.getLocation());\n}\n\nexport function buildStore(\n  history: HistoryProxy<any>,\n  preloadedState: {[key: string]: any} = {},\n  storeReducers: ReducersMapObject<any, any> = {},\n  storeMiddlewares: Middleware[] = [],\n  storeEnhancers: StoreEnhancer[] = []\n): ModelStore {\n  if (storeReducers.route) {\n    throw new Error(\"the reducer name 'route' is not allowed\");\n  }\n  storeReducers.route = (state: RouteState, action: Action) => {\n    if (action.type === ActionTypes.RouteChange) {\n      const payload: RouteState = getActionData(action)[0];\n      if (!state) {\n        return payload;\n      }\n      return {...state, ...payload};\n    }\n    return state;\n  };\n\n  const combineReducers = (rootState: StoreState, action: Action) => {\n    if (!store) {\n      return rootState;\n    }\n    const meta = store._medux_;\n    meta.prevState = rootState;\n    const currentState = {...rootState};\n    meta.currentState = currentState;\n    Object.keys(storeReducers).forEach((moduleName) => {\n      currentState[moduleName] = storeReducers[moduleName](currentState[moduleName], action);\n    });\n\n    const handlersCommon = meta.reducerMap[action.type] || {};\n    // 支持泛监听，形如 */loading\n    const handlersEvery = meta.reducerMap[action.type.replace(new RegExp(`[^${config.NSP}]+`), '*')] || {};\n    const handlers = {...handlersCommon, ...handlersEvery};\n    const handlerModules = Object.keys(handlers);\n\n    if (handlerModules.length > 0) {\n      const orderList: string[] = [];\n      const priority: string[] = action.priority ? [...action.priority] : [];\n      handlerModules.forEach((moduleName) => {\n        const fun = handlers[moduleName];\n        if (moduleName === MetaData.appModuleName) {\n          orderList.unshift(moduleName);\n        } else {\n          orderList.push(moduleName);\n        }\n        if (!fun.__isHandler__) {\n          priority.unshift(moduleName);\n        }\n      });\n      orderList.unshift(...priority);\n      const moduleNameMap: {[key: string]: boolean} = {};\n      orderList.forEach((moduleName) => {\n        if (!moduleNameMap[moduleName]) {\n          moduleNameMap[moduleName] = true;\n          const fun = handlers[moduleName];\n          currentState[moduleName] = fun(...getActionData(action));\n        }\n      });\n    }\n\n    const changed = Object.keys(rootState).length !== Object.keys(currentState).length || Object.keys(rootState).some((moduleName) => rootState[moduleName] !== currentState[moduleName]);\n    meta.prevState = changed ? currentState : rootState;\n    return meta.prevState;\n  };\n  const middleware = ({dispatch}: {dispatch: Function}) => (next: Function) => (originalAction: Action) => {\n    if (MetaData.isServer) {\n      if (originalAction.type.split(config.NSP)[1] === ActionTypes.MLoading) {\n        return originalAction;\n      }\n    }\n    const meta = store._medux_;\n    meta.beforeState = meta.prevState;\n    const action: Action = next(originalAction);\n    if (action.type === ActionTypes.RouteChange) {\n      const rootRouteParams = meta.prevState.route.data.params;\n      Object.keys(rootRouteParams).forEach((moduleName) => {\n        const routeParams = rootRouteParams[moduleName];\n        if (routeParams && Object.keys(routeParams).length > 0 && meta.injectedModules[moduleName]) {\n          dispatch(routeParamsAction(moduleName, routeParams));\n        }\n      });\n    }\n    const handlersCommon = meta.effectMap[action.type] || {};\n    // 支持泛监听，形如 */loading\n    const handlersEvery = meta.effectMap[action.type.replace(new RegExp(`[^${config.NSP}]+`), '*')] || {};\n    const handlers = {...handlersCommon, ...handlersEvery};\n    const handlerModules = Object.keys(handlers);\n\n    if (handlerModules.length > 0) {\n      const orderList: string[] = [];\n      const priority: string[] = action.priority ? [...action.priority] : [];\n      handlerModules.forEach((moduleName) => {\n        const fun = handlers[moduleName];\n        if (moduleName === MetaData.appModuleName) {\n          orderList.unshift(moduleName);\n        } else {\n          orderList.push(moduleName);\n        }\n        if (!fun.__isHandler__) {\n          priority.unshift(moduleName);\n        }\n      });\n      orderList.unshift(...priority);\n      const moduleNameMap: {[key: string]: boolean} = {};\n      const promiseResults: Promise<any>[] = [];\n      orderList.forEach((moduleName) => {\n        if (!moduleNameMap[moduleName]) {\n          moduleNameMap[moduleName] = true;\n          const fun = handlers[moduleName];\n          const effectResult = fun(...getActionData(action));\n          const decorators = fun.__decorators__;\n          if (decorators) {\n            const results: any[] = [];\n            decorators.forEach((decorator, index) => {\n              results[index] = decorator[0](action, moduleName, effectResult);\n            });\n            fun.__decoratorResults__ = results;\n          }\n\n          const errorHandler = effectResult.then(\n            (reslove: any) => {\n              if (decorators) {\n                const results = fun.__decoratorResults__ || [];\n                decorators.forEach((decorator, index) => {\n                  if (decorator[1]) {\n                    decorator[1]('Resolved', results[index], reslove);\n                  }\n                });\n                fun.__decoratorResults__ = undefined;\n              }\n              return reslove;\n            },\n            (error: any) => {\n              if (decorators) {\n                const results = fun.__decoratorResults__ || [];\n                decorators.forEach((decorator, index) => {\n                  if (decorator[1]) {\n                    decorator[1]('Rejected', results[index], error);\n                  }\n                });\n                fun.__decoratorResults__ = undefined;\n              }\n              if (action.type === ActionTypes.Error) {\n                if (isProcessedError(error) === undefined) {\n                  error = setProcessedError(error, true);\n                }\n                throw error;\n              } else if (isProcessedError(error)) {\n                throw error;\n              } else {\n                return dispatch(errorAction(error)) as any;\n              }\n            }\n          );\n\n          promiseResults.push(errorHandler);\n        }\n      });\n      if (promiseResults.length) {\n        return Promise.all(promiseResults);\n      }\n    }\n    return action;\n  };\n\n  const preLoadMiddleware = () => (next: Function) => (action: Action) => {\n    const [moduleName, actionName] = action.type.split(config.NSP);\n    if (moduleName && actionName && MetaData.moduleGetter[moduleName]) {\n      const initModel = loadModel(moduleName, store, undefined);\n      if (isPromise(initModel)) {\n        return initModel.then(() => next(action));\n      }\n    }\n    return next(action);\n  };\n\n  const middlewareEnhancer = applyMiddleware(preLoadMiddleware, ...storeMiddlewares, middleware);\n  const enhancer: StoreEnhancer = (newCreateStore) => {\n    return (...args) => {\n      const newStore = newCreateStore(...args);\n      const modelStore: ModelStore = newStore as any;\n      modelStore._medux_ = {\n        beforeState: {} as any,\n        prevState: {} as any,\n        currentState: {} as any,\n        reducerMap: {},\n        effectMap: {},\n        injectedModules: {},\n        currentViews: {},\n      };\n      return newStore;\n    };\n  };\n  const enhancers = [...storeEnhancers, middlewareEnhancer, enhancer];\n  if (MetaData.isDev && client && client.__REDUX_DEVTOOLS_EXTENSION__) {\n    enhancers.push(client.__REDUX_DEVTOOLS_EXTENSION__(client.__REDUX_DEVTOOLS_EXTENSION__OPTIONS));\n  }\n  const store: ModelStore = createStore(combineReducers as any, preloadedState, compose(...enhancers));\n  bindHistory(store, history);\n  MetaData.clientStore = store;\n  return store;\n}\n","import {Action, ActionCreatorList, ActionHandler, BaseModelState, MetaData, ModelStore, RouteState, StoreState, client, config, injectActions, isPromise, reducer} from './basic';\nimport {HistoryProxy, buildStore, loadModel} from './store';\nimport {Middleware, ReducersMapObject, Store, StoreEnhancer} from 'redux';\n\nexport interface Model<ModelState extends BaseModelState = BaseModelState> {\n  moduleName: string;\n  initState: ModelState;\n  (store: ModelStore, options?: any): void | Promise<void>;\n}\n\nexport interface Module<M extends Model = Model, VS extends {[key: string]: any} = {[key: string]: any}, AS extends ActionCreatorList = {}, N extends string = string> {\n  default: {\n    moduleName: N;\n    model: M;\n    views: VS;\n    actions: AS;\n  };\n}\n\nexport interface ModuleGetter {\n  [moduleName: string]: () => Module | Promise<Module>;\n}\n\ntype ReturnModule<T> = T extends () => Promise<infer R> ? R : T extends () => infer R ? R : never;\n// export type ReturnViews<T extends () => any> = T extends () => Promise<Module<Model, infer R>> ? R : T extends () => Module<Model, infer R> ? R : never;\ntype ModuleName<M extends any> = M['default']['moduleName'];\ntype ModuleStates<M extends any> = M['default']['model']['initState'];\ntype ModuleParams<M extends any> = M['default']['model']['initState']['routeParams'];\ntype ModuleViews<M extends any> = M['default']['views'];\ntype ModuleActions<M extends any> = M['default']['actions'];\ntype MountViews<M extends any> = {[key in keyof M['default']['views']]?: boolean};\n\nexport type RouteViews<G extends ModuleGetter> = {[key in keyof G]?: MountViews<ReturnModule<G[key]>>};\nexport type RootState<G extends ModuleGetter, L> = {\n  route: {\n    location: L;\n    data: {\n      views: RouteViews<G>;\n      params: {[key in keyof G]?: ModuleParams<ReturnModule<G[key]>>};\n      stackParams: {[moduleName: string]: {[key: string]: any} | undefined}[];\n      paths: string[];\n    };\n  };\n} & {[key in keyof G]?: ModuleStates<ReturnModule<G[key]>>};\n\nexport type ExportModule<Component> = <S extends BaseModelState, V extends {[key: string]: Component}, T extends BaseModelHandlers<S, any>, N extends string>(\n  moduleName: N,\n  initState: S,\n  ActionHandles: {new (moduleName: string, store: any): T},\n  views: V\n) => Module<Model<S>, V, Actions<T>, N>['default'];\n\nexport const exportModule: ExportModule<any> = (moduleName, initState, ActionHandles, views) => {\n  const model = (store: ModelStore, options?: any) => {\n    const hasInjected = store._medux_.injectedModules[moduleName];\n    if (!hasInjected) {\n      store._medux_.injectedModules[moduleName] = true;\n      const moduleState: BaseModelState = store.getState()[moduleName];\n      const handlers = new ActionHandles(moduleName, store);\n      const actions = injectActions(store, moduleName, handlers as any);\n      (handlers as any).actions = actions;\n      if (!moduleState) {\n        const params = store._medux_.prevState.route.data.params;\n        initState.isModule = true;\n        const initAction = actions.Init(initState, params[moduleName], options);\n        return store.dispatch(initAction) as any;\n      }\n    }\n    return void 0;\n  };\n  model.moduleName = moduleName;\n  model.initState = initState;\n  const actions = {} as any;\n  return {\n    moduleName,\n    model,\n    views,\n    actions,\n  };\n};\n\nexport abstract class BaseModelHandlers<S extends BaseModelState, R extends {route: RouteState}> {\n  protected readonly actions: Actions<this> = null as any;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public constructor(protected readonly moduleName: string, protected readonly store: ModelStore) {}\n\n  protected get state(): S {\n    return this.getState();\n  }\n  //ie8不支持getter\n  protected getState(): S {\n    return this.store._medux_.prevState[this.moduleName] as S;\n  }\n  protected get rootState(): R {\n    return this.getRootState();\n  }\n  //ie8不支持getter\n  protected getRootState(): R {\n    return this.store._medux_.prevState as any;\n  }\n  protected get currentState(): S {\n    return this.getCurrentState();\n  }\n  //ie8不支持getter\n  protected getCurrentState(): S {\n    return this.store._medux_.currentState[this.moduleName] as S;\n  }\n  protected get currentRootState(): R {\n    return this.getCurrentRootState();\n  }\n  //ie8不支持getter\n  protected getCurrentRootState(): R {\n    return this.store._medux_.currentState as any;\n  }\n  protected get beforeState(): undefined | S {\n    return this.getBeforeState();\n  }\n  //ie8不支持getter\n  protected getBeforeState(): undefined | S {\n    return this.store._medux_.beforeState[this.moduleName] as S;\n  }\n  protected get beforeRootState(): R {\n    return this.getBeforeRootState();\n  }\n  //ie8不支持getter\n  protected getBeforeRootState(): R {\n    return this.store._medux_.beforeState as any;\n  }\n  protected dispatch(action: Action): Action | Promise<void> {\n    return this.store.dispatch(action) as any;\n  }\n\n  protected callThisAction<T extends any[]>(handler: (...args: T) => any, ...rest: T): {type: string; payload?: any[]} {\n    const actions = MetaData.actionCreatorMap[this.moduleName];\n    return actions[(handler as ActionHandler).__actionName__](...rest);\n  }\n  protected updateState(payload: Partial<S>) {\n    this.dispatch(this.callThisAction(this.Update, {...this.getState(), ...payload}));\n  }\n  protected loadModel(moduleName: Extract<keyof R, string>, options?: any) {\n    return loadModel(moduleName, this.store, options);\n  }\n  @reducer\n  protected Init(initState: S, routeParams?: any, options?: any): S {\n    return {...initState, routeParams: routeParams || initState.routeParams, ...options};\n  }\n\n  @reducer\n  protected Update(payload: S): S {\n    return payload;\n  }\n\n  @reducer\n  public RouteParams(payload: {[key: string]: any}): S {\n    const state = this.getState();\n    return {\n      ...state,\n      routeParams: payload,\n    };\n  }\n\n  @reducer\n  protected Loading(payload: {[group: string]: string}): S {\n    const state = this.getState();\n    return {\n      ...state,\n      loading: {...state.loading, ...payload},\n    };\n  }\n}\n\ntype Handler<F> = F extends (...args: infer P) => any\n  ? (\n      ...args: P\n    ) => {\n      type: string;\n    }\n  : never;\n\nexport type Actions<Ins> = {[K in keyof Ins]: Ins[K] extends (...args: any[]) => any ? Handler<Ins[K]> : never};\n\nexport function isPromiseModule(module: Module | Promise<Module>): module is Promise<Module> {\n  return typeof module['then'] === 'function';\n}\nexport function isPromiseView<T>(moduleView: T | Promise<T>): moduleView is Promise<T> {\n  return typeof moduleView['then'] === 'function';\n}\n\nexport function exportActions<G extends {[N in keyof G]: N extends ModuleName<ReturnModule<G[N]>> ? G[N] : never}>(moduleGetter: G): {[key in keyof G]: ModuleActions<ReturnModule<G[key]>>} {\n  MetaData.moduleGetter = moduleGetter as any;\n  MetaData.actionCreatorMap = Object.keys(moduleGetter).reduce((maps, moduleName) => {\n    maps[moduleName] =\n      typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(\n            {},\n            {\n              get: (target: {}, key: string) => {\n                return (...payload: any[]) => ({type: moduleName + config.NSP + key, payload});\n              },\n              set: () => {\n                return true;\n              },\n            }\n          );\n    return maps;\n  }, {});\n  return MetaData.actionCreatorMap as any;\n}\n\nexport function getView<T>(moduleName: string, viewName: string, modelOptions?: any): T | Promise<T> {\n  const moduleGetter: ModuleGetter = MetaData.moduleGetter;\n  const result = moduleGetter[moduleName]();\n  if (isPromiseModule(result)) {\n    return result.then((module) => {\n      moduleGetter[moduleName] = () => module;\n      const view: T = module.default.views[viewName];\n      if (MetaData.isServer) {\n        return view;\n      }\n      const initModel = module.default.model(MetaData.clientStore, modelOptions);\n      if (isPromise(initModel)) {\n        return initModel.then(() => view);\n      } else {\n        return view;\n      }\n    });\n  } else {\n    const view: T = result.default.views[viewName];\n    if (MetaData.isServer) {\n      return view;\n    }\n    const initModel = result.default.model(MetaData.clientStore, modelOptions);\n    if (isPromise(initModel)) {\n      return initModel.then(() => view);\n    } else {\n      return view;\n    }\n  }\n}\n\nexport type LoadView<MG extends ModuleGetter, Options = any, Loading = any> = <M extends Extract<keyof MG, string>, V extends ModuleViews<ReturnModule<MG[M]>>, N extends Extract<keyof V, string>>(\n  moduleName: M,\n  viewName: N,\n  options?: Options,\n  loading?: Loading\n) => V[N];\n\nfunction getModuleByName(moduleName: string, moduleGetter: ModuleGetter): Promise<Module> | Module {\n  const result = moduleGetter[moduleName]();\n  if (isPromiseModule(result)) {\n    return result.then((module) => {\n      //在SSR时loadView不能出现异步，否则浏览器初轮渲染不会包括异步组件，从而导致和服务器返回不一致\n      moduleGetter[moduleName] = () => module;\n      return module;\n    });\n  } else {\n    return result;\n  }\n}\nfunction getModuleListByNames(moduleNames: string[], moduleGetter: ModuleGetter): Promise<Module[]> {\n  const preModules = moduleNames.map((moduleName) => {\n    const module = getModuleByName(moduleName, moduleGetter);\n    if (isPromiseModule(module)) {\n      return module;\n    } else {\n      return Promise.resolve(module);\n    }\n  });\n  return Promise.all(preModules);\n}\nexport interface StoreOptions {\n  ssrInitStoreKey?: string;\n  reducers?: ReducersMapObject;\n  middlewares?: Middleware[];\n  enhancers?: StoreEnhancer[];\n  initData?: {[key: string]: any};\n}\n\nexport function renderApp<M extends ModuleGetter, A extends Extract<keyof M, string>>(\n  render: (store: Store, appModel: Model, appViews: {[key: string]: any}, ssrInitStoreKey: string) => void,\n  moduleGetter: M,\n  appModuleName: A,\n  history: HistoryProxy,\n  storeOptions: StoreOptions = {}\n): Promise<Store> {\n  MetaData.appModuleName = appModuleName;\n  const ssrInitStoreKey = storeOptions.ssrInitStoreKey || 'meduxInitStore';\n  let initData = {};\n  if (storeOptions.initData || client![ssrInitStoreKey]) {\n    initData = {...client![ssrInitStoreKey], ...storeOptions.initData};\n  }\n  const store = buildStore(history, initData, storeOptions.reducers, storeOptions.middlewares, storeOptions.enhancers);\n  const reduxStore: Store = store as any;\n  const preModuleNames: string[] = [appModuleName];\n  if (initData) {\n    preModuleNames.push(...Object.keys(initData).filter((key) => key !== appModuleName && initData[key].isModule));\n  }\n  // 在ssr时，client必须在第一次render周期中完成和ssr一至的输出结构，所以不能出现异步模块\n  return getModuleListByNames(preModuleNames, moduleGetter).then(([appModule]) => {\n    const initModel = appModule.default.model(store, undefined);\n    render(reduxStore, appModule.default.model, appModule.default.views, ssrInitStoreKey);\n    if (isPromise(initModel)) {\n      return initModel.then(() => reduxStore);\n    } else {\n      return reduxStore;\n    }\n  });\n}\n\nexport async function renderSSR<M extends ModuleGetter, A extends Extract<keyof M, string>>(\n  render: (store: Store, appModel: Model, appViews: {[key: string]: any}, ssrInitStoreKey: string) => {html: any; data: any; ssrInitStoreKey: string; store: Store},\n  moduleGetter: M,\n  appModuleName: A,\n  history: HistoryProxy,\n  storeOptions: StoreOptions = {}\n) {\n  MetaData.appModuleName = appModuleName;\n  const ssrInitStoreKey = storeOptions.ssrInitStoreKey || 'meduxInitStore';\n  const store = buildStore(history, storeOptions.initData, storeOptions.reducers, storeOptions.middlewares, storeOptions.enhancers);\n  const storeState = store.getState() as StoreState;\n  const {paths} = storeState.route.data;\n  paths.length === 0 && paths.push(appModuleName);\n  let appModule: Module | undefined = undefined;\n  const inited: {[moduleName: string]: boolean} = {};\n  for (let i = 0, k = paths.length; i < k; i++) {\n    const [moduleName] = paths[i].split(config.VSP);\n    if (!inited[moduleName]) {\n      inited[moduleName] = true;\n      const module = moduleGetter[moduleName]() as Module;\n      await module.default.model(store, undefined);\n      if (i === 0) {\n        appModule = module;\n      }\n    }\n  }\n  return render(store as any, appModule!.default.model, appModule!.default.views, ssrInitStoreKey);\n}\n"],"names":["LoadingState","PEvent","name","data","bubbling","setTarget","target","setCurrentTarget","currentTarget","TaskCounter","deferSecond","addItem","promise","note","this","list","some","item","push","then","_this3","completeItem","length","dispatch","Start","ctimer","setTimeout","Depth","i","findIndex","splice","clearTimeout","Stop","parent","addListener","ename","handler","dictionary","storeHandlers","removeListener","handlers","propertyIsEnumerable","n","indexOf","Object","keys","forEach","key","_this","evt","k","setParent","loadings","depthTime","setLoading","moduleName","group","MetaData","appModuleName","isServer","config","NSP","e","store","clientStore","action","actions","actionCreatorMap","ActionTypes","MLoading","VSP","MSP","global","window","isDev","process","env","NODE_ENV","moduleGetter","MInit","MRouteParams","Error","RouteChange","client","undefined","isPromise","reducer","descriptor","fun","value","__actionName__","__isReducer__","enumerable","isProcessedError","error","meduxProcessed","transformAction","actionName","listenerModule","actionHandlerMap","addModuleActionCreatorList","payload","type","errorAction","routeChangeAction","route","routeParamsAction","params","loadModel","options","_medux_","injectedModules","result","module","default","model","getActionData","Array","isArray","buildStore","history","preloadedState","storeReducers","storeMiddlewares","storeEnhancers","state","middlewareEnhancer","applyMiddleware","next","split","initModel","originalAction","meta","beforeState","prevState","rootRouteParams","routeParams","handlersCommon","effectMap","handlersEvery","replace","RegExp","handlerModules","orderList","priority","unshift","__isHandler__","moduleNameMap","promiseResults","effectResult","decorators","__decorators__","results","decorator","index","__decoratorResults__","errorHandler","reslove","setProcessedError","Promise","all","enhancers","newCreateStore","newStore","modelStore","currentState","reducerMap","currentViews","__REDUX_DEVTOOLS_EXTENSION__","__REDUX_DEVTOOLS_EXTENSION__OPTIONS","createStore","rootState","changed","compose","inTimeTravelling","handleLocationChange","location","getState","equal","locationToRouteData","subscribe","initialized","storeRouteState","getLocation","patch","bindHistory","BaseModelHandlers","getRootState","getCurrentState","getCurrentRootState","getBeforeState","getBeforeRootState","rest","callThisAction","Update","initState","loading","isPromiseModule","getModuleListByNames","moduleNames","preModules","map","getModuleByName","resolve","render","storeOptions","ssrInitStoreKey","initData","reducers","middlewares","storeState","paths","appModule","inited","views","second","delay","args","apply","items","loadingForGroupName","loadingForModuleName","__isEffect__","curAction","promiseResult","reduce","maps","Proxy","get","set","ActionHandles","moduleState","actionNames","thisObj","newFun","bind","trim","injectActions","isModule","initAction","Init","viewName","modelOptions","view","moduleView","before","after","reduxStore","preModuleNames","filter","_config"],"mappings":"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"}