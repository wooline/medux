{"version":3,"sources":["../../src/index.ts"],"names":["createBrowserHistory","createMemoryHistory","createHashHistory","isLocation","data","BrowserHistoryProxy","constructor","history","locationToRoute","getLocation","location","subscribe","listener","listen","locationToRouteData","state","equal","a","b","pathname","search","hash","patch","routeData","push","BrowserHistoryActions","routeToLocation","replace","go","n","goBack","goForward","createHistory","transformRoute","historyProxy","historyActions"],"mappings":"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","sourcesContent":["import {HistoryProxy, RouteData} from '@medux/core/types/export';\n\nimport {History} from 'history';\n\nexport {createBrowserHistory, createMemoryHistory, createHashHistory} from 'history';\n\ninterface BrowserLocation {\n  pathname: string;\n  search: string;\n  hash: string;\n  state: RouteData;\n}\n\nexport interface Location {\n  pathname: string;\n  search: string;\n  hash: string;\n}\n\nexport type RouteToLocation = (routeData: RouteData) => Location;\nexport type LocationToRoute = (location: Location) => RouteData;\n\nexport interface TransformRoute {\n  locationToRoute: LocationToRoute;\n  routeToLocation: RouteToLocation;\n}\n\nfunction isLocation(data: RouteData | Location): data is Location {\n  return !!data['pathname'];\n}\n\nexport interface HistoryActions<P = RouteData> {\n  push(data: P | Location | string): void;\n  replace(data: P | Location | string): void;\n  go(n: number): void;\n  goBack(): void;\n  goForward(): void;\n}\nclass BrowserHistoryProxy implements HistoryProxy<BrowserLocation> {\n  public initialized = true;\n  public constructor(protected history: History, protected locationToRoute: LocationToRoute) {}\n  public getLocation() {\n    return this.history.location;\n  }\n  public subscribe(listener: (location: BrowserLocation) => void) {\n    this.history.listen(listener);\n  }\n  public locationToRouteData(location: BrowserLocation) {\n    return location.state || this.locationToRoute(location);\n  }\n  public equal(a: BrowserLocation, b: BrowserLocation) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n  public patch(location: BrowserLocation, routeData: RouteData): void {\n    this.history.push({...location, state: routeData});\n  }\n}\n\nclass BrowserHistoryActions implements HistoryActions {\n  public constructor(protected history: History, protected routeToLocation: RouteToLocation) {}\n  public push(data: RouteData | Location | string): void {\n    if (typeof data === 'string') {\n      this.history.push(data);\n    } else if (isLocation(data)) {\n      this.history.push(data);\n    } else {\n      const location = this.routeToLocation(data as RouteData);\n      this.history.push({...location, state: data});\n    }\n  }\n  public replace(data: RouteData | Location | string): void {\n    if (typeof data === 'string') {\n      this.history.replace(data);\n    } else if (isLocation(data)) {\n      this.history.replace(data);\n    } else {\n      const location = this.routeToLocation(data as RouteData);\n      this.history.replace({...location, state: data});\n    }\n  }\n  public go(n: number) {\n    this.history.go(n);\n  }\n  public goBack() {\n    this.history.goBack();\n  }\n  public goForward() {\n    this.history.goForward();\n  }\n}\n\nexport function createHistory(history: History, transformRoute: TransformRoute) {\n  const historyProxy: HistoryProxy<BrowserLocation> = new BrowserHistoryProxy(history, transformRoute.locationToRoute);\n  const historyActions: HistoryActions = new BrowserHistoryActions(history, transformRoute.routeToLocation);\n  return {\n    historyProxy,\n    historyActions,\n  };\n}\n"],"file":"index.js"}